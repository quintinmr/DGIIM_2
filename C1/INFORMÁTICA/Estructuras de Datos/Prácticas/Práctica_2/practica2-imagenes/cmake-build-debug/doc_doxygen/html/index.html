<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Práctica 2. Imágenes: Astracción. TDA Imagen</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Práctica 2. Imágenes
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Astracción. TDA Imagen </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="image">
<img src="monal.png" alt=""/>
</div>
<h1><a class="anchor" id="autotoc_md0"></a>
Información sobre Doxygen</h1>
<p>Doxygen admite el uso de la <a href="https://www.markdownguide.org/basic-syntax">sintaxis de Markdown (Consulta aquí los comandos básicos)</a>.</p>
<p>Así como el uso de <a href="https://htmlcheatsheet.com/">sintaxis <b>HTML</b></a>. Esto es especialmente útil para aquellos aspectos que Markdown no permite modificar, como el <span style="color:red">color</span>. Aunque es buena idea evitarlo en la medida de lo posible, por dos motivos:</p>
<ol type="1">
<li><span style="font-size:1.1em">Hace el código <b>poco</b> <span style="  background-image: linear-gradient(to left, #4285f4, #34a853, #fbbc05, #ea4335); -webkit-background-clip: text; color: transparent;"> <b> LEGIBLE </b> </span></span></li>
<li>La idea detrás de Markdown es separar <em>aspecto</em> y <em>contenido</em>. Y es una <b>gran idea</b>.</li>
</ol>
<p>La forma más correcta de modificar el aspecto debería ser mediante un documento <code>.css</code> configurado en el archivo <code>Doxyfile.in</code>. Si te interesa, puedes echarle un vistazo a la <a href="https://www.doxygen.nl/manual/customize.html">documentación</a> o a temas customizados como <a href="https://jothepro.github.io/doxygen-awesome-css/">este</a>. Aunque el tema por defecto nos parece perfecto, <em>CLÁSICO</em>. Así puedes centrarte en el contenido.</p>
<p>Por último, lo hemos visto en clase y hay suficientes ejemplos en el código fuente proporcionado, pero puedes consultar la mayor parte de la sintaxis de Doxygen para comentar código en su <a href="https://www.doxygen.nl/manual/docblocks.html">documentación</a>.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Introducción</h1>
<p>Si pensamos en el concepto de imagen, seguramente lo primero que se nos viene a la cabeza es una representación visual de un objeto, persona, o lugar, bien sean reales o imaginarios. La realidad que nos rodea y la que nos imaginamos da lugar a miles de millones de imágenes, con infinidad de detalles que difieren unos de otros, pero, dado que el ser humano es un ser racional, somos capaces de realizar un proceso de abstracción sobre el concepto de imagen. Este hecho nos permite definir un tipo de dato abstracto Imagen, sobre el cual trata esta práctica. En ella, nos centramos en una instancia del tipo de dato abstracto Imagen, la cual nos permite almacenar imágenes de intensidades. Además dicho TDA nos aporta múltiples herramientas para la manipulación de dichas imágenes, que se verán a contiuación. Se han implementado una serie de métodos que modifican imágenes o generan otras con características distintas a las del objeto inicial, cada uno de los cuales tiene un fichero ejecutable .cpp asociado:</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Ejecutables</h1>
<div class="image">
<img src="invert2.png" alt=""/>
<div class="caption">
Imagen Original ➔ Negativo</div></div>
 <h2><a class="anchor" id="autotoc_md3"></a>
Negativo:</h2>
<p>Programa que calcula el negativo de una imagen. Trabaja sobre la imagen original que se le especifique como parámetro modificando cada uno de sus píxeles por su correspondiente complementario. El complementario de un pixel de intensidad <em>x</em> es <em>255-x</em></p>
<blockquote class="doxtable">
<p><b>negativo</b> &lt;FichImagenOriginal&gt; &lt;FichImagenDestino&gt; </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&lt;FichImagenOriginal&gt;</td><td>Imagen PGM a la que se va a calcular </td></tr>
    <tr><td class="paramname">&lt;FichImagenDestino&gt;</td><td>Imagen PGM resultado de calcular el negativo </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>La imagen se modifica y los píxeles tendrán valores complementarios.</dd></dl>
<div class="image">
<img src="crop.png" alt=""/>
<div class="caption">
Imagen Original ➔ Subimagen</div></div>
 <h2><a class="anchor" id="autotoc_md4"></a>
Subimagen:</h2>
<p>Programa que realiza, por copia, la extracción de una subimagen, de la imagen que se le especifique como parámetro, necesariamente de un tamaño menor o igual que la original.</p>
<blockquote class="doxtable">
<p><b>subimagen</b> &lt;FichImagenOriginal&gt; &lt;FichImagenDestino&gt; &lt;nrow&gt; &lt;ncol&gt; &lt;height&gt; &lt;width&gt; </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&lt;FichImagenOriginal&gt;</td><td>Imagen que se va a recortar </td></tr>
    <tr><td class="paramname">&lt;FichImagenDestino&gt;</td><td>Imagen PGM resultado de recortar la imagen </td></tr>
    <tr><td class="paramname">nrow</td><td>Fila inicial para recortar (esquina superior izquierda) </td></tr>
    <tr><td class="paramname">ncol</td><td>Columna inicial para recortar (esquina superior izquierda) </td></tr>
    <tr><td class="paramname">height</td><td>Altura de la imagen recortada; número de filas </td></tr>
    <tr><td class="paramname">width</td><td>Ancho de la imagen recortada; número de columnas </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= nrow &lt; rows, 0 &lt;= ncol &lt; cols </dd>
<dd>
0 &lt; height &lt;= rows - nrow, 0 &lt; width &lt;= cols - ncol </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Imagen con el recorte </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>El objeto que llama a la función no se modifica</dd></dl>
<div class="image">
<img src="zoom.png" alt=""/>
<div class="caption">
Imagen Original ➔ zoom2x</div></div>
<h2><a class="anchor" id="autotoc_md5"></a>
Zoom2x:</h2>
<p>Programa mediante el cual se obtiene una nueva imagen del doble de tamaño, asignando a la nueva imagen los pixeles de la imagen anterior pero en una nueva posición (la correspondiente a duplicar la posición anterior). Se lleva a cabo un proceso de varias interpolaciones: una primera interpolación por columnas asigando a los pixeles de las filas pares y columnas impares la media de los elementos que tienen a la derecha e izquierda. Luego una segunda interpolación por filas asignando a los pixeles de las filas impares y columnas pares la media de los elementos que tienen justo encima y debajo. Por último, se rellenan los elementos de las filas impares y columnas impares (centrales) con la media de los elementos que tienen en sus esquinas.</p>
<blockquote class="doxtable">
<p><b>zoom2x</b> &lt;FichImagenOriginal&gt; &lt;FichImagenDestino&gt; &lt;nrow&gt; &lt;ncol&gt; &lt;side&gt; </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&lt;FichImagenOriginal&gt;</td><td>Imagen a la que se le va a hacer el zoom </td></tr>
    <tr><td class="paramname">&lt;FichImagenDestino&gt;</td><td>Imagen PGM resultado de aumentar la imagen x2 </td></tr>
    <tr><td class="paramname">nrow</td><td>Fila incial para ampliar (esquina superior izquierda) </td></tr>
    <tr><td class="paramname">ncol</td><td>Columan incial para ampliar (esquina superior izquierda) </td></tr>
    <tr><td class="paramname">side</td><td>lado de la imagen aumentada </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>La matriz original debe ser cuadrada (rows == cols) </dd>
<dd>
0 &lt;= nrow &lt; rows, 0 &lt;= ncol &lt; cols </dd>
<dd>
0 &lt; side &lt;= rows - nrow </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Imagen aumentada 2x </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>El objeto que llama a la función no se modifica</dd></dl>
<div class="image">
<img src="icono.png" alt=""/>
<div class="caption">
Imagen Original ➔ Icono</div></div>
<h2><a class="anchor" id="autotoc_md6"></a>
Icono:</h2>
<p>Programa que genera un icono a partir de una imagen, es decir, devuelve una imagen de un tamaño muy reducido, a partir de la imagen original que se le especifique como parámetro. El proceso que se sigue para la reducción de la imagen consiste en la modificación de cada uno de sus píxeles por la media de los <em>NxN</em> píxeles de la imagen de entrada, en el caso de que el factor de reducción a aplicar sea de <em>Nx</em>. Para el cálculo de las medias antes mencionadas, se ha implementado el método adicional <b>Mean</b></p>
<blockquote class="doxtable">
<p><b>icono</b> &lt;FichImagenOriginal&gt; &lt;FichImagenDestino&gt; &lt;factor&gt; </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&lt;FichImagenOriginal&gt;</td><td>Imagen que se va a iconizar </td></tr>
    <tr><td class="paramname">&lt;FichImagenDestino&gt;</td><td>Imagen PGM en la que se guarda la imagen iconizada </td></tr>
    <tr><td class="paramname">factor</td><td>Factor de reducción </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>factor &gt; 0 </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Imagen iconizada </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>La imagen inicial no se modifica </dd>
<dd>
La imagen iconizada será de orden int(rows/fcator) x int(cols/factor)</dd></dl>
<div class="image">
<img src="contraste.png" alt=""/>
<div class="caption">
Imagen Original ➔ Modificación de contraste</div></div>
<h2><a class="anchor" id="autotoc_md7"></a>
Contraste:</h2>
<p>Porgrama que modifica el contraste de una imagen, generando una imagen de niveles de gris con más contraste que la original. Para ello, se aplica lo que se conoce como: <em>estiramiento del histograma</em>, que consiste en la aplicación de una transformación lineal a trozos sobre los valores de los píxeles de la imagen. Dicha transformación lineal depende del valor de cada uno de los píxeles y se ha deducido su implementación de la siguiente gŕafica: </p><div class="image">
<img src="trfl.png" alt=""/>
</div>
<blockquote class="doxtable">
<p><b>contraste</b> &lt;FichImagenOriginal&gt; &lt;FichImagenDestino&gt; &lt;in1&gt; &lt;in2&gt; &lt;in3&gt; &lt;in4&gt; </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&lt;FichImagenOriginal&gt;</td><td>Imagen a la que se le va a modificar el contraste </td></tr>
    <tr><td class="paramname">&lt;FichImagenDestino&gt;</td><td>Imagen PGM con el contraste modificado </td></tr>
    <tr><td class="paramname">in1</td><td>Umbral inferior de la imagen de entrada </td></tr>
    <tr><td class="paramname">in2</td><td>Umbral superior de la imagen de entrada </td></tr>
    <tr><td class="paramname">out1</td><td>Umbral inferior de la imagen de salida </td></tr>
    <tr><td class="paramname">out2</td><td>Umbral superior de la imagen de salida </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= (in1, in2, out1, out2) &lt;= 255 </dd>
<dd>
in1 &lt; in2 </dd>
<dd>
out1 &lt; out2 </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>El objeto que llama a la función es modificado</dd></dl>
<div class="image">
<img src="shufflerows.png" alt=""/>
<div class="caption">
Imagen Original ➔ Imagen barajada</div></div>
<h2><a class="anchor" id="autotoc_md8"></a>
ShuffleRows:</h2>
<p>Programa que baraja pseudoaleatoriamente las filas de una imagen. La imagen original, tras la ejecución del programa, ve alterada sus filas, dispuestas en otro orden según el algoritmo: <em><b>r' = (rxp) mod rows</b></em>, donde r' es el nuevo índice de la fila r, p es un coprimo de rows y rows es el número de filas de la imagen.</p>
<blockquote class="doxtable">
<p><b>shuffleRows</b> &lt;FichImagenOriginal&gt; &lt;FichImagenDestino&gt; </p>
</blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&lt;FichImagenOriginal&gt;</td><td>Imagen original a la que se le van a barajar las filas </td></tr>
    <tr><td class="paramname">&lt;FichImagenDestino&gt;</td><td>Imagen PGM con las filas barajadas </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>El objeto que llama a la función se modifica. Las filas quedan barajadas.</dd></dl>
<h3><a class="anchor" id="autotoc_md9"></a>
Análisis de la eficiencia teórica y empírica del método ShuffleRows</h3>
<p>En esta sección se va a realizar un análisis sobre la eficiencia tanto teórica como empírica, del método ShuffleRows. Para la eficiencia empírica, se ha creado un programa <a href="https://drive.google.com/file/d/1e--q2_Osmy6E3dc7PKlUzwpWhZm9s4fY/view"><b>crear_eficiencia.cpp</b></a>, para analizar la complejidad en tiempo del método anteriormente mencionado, es decir, mediremos tiempos de ejecución de las dos implementaciones que tenemos del método para diferentes entradas de datos. Dicho programa vierte sus salidas en un fichero destino. A partir de esas salidas, con la ayuda del programa <em><b>excel</b></em>, se obtendrán unas gráficas en las que se reperesetaran las nubes de puntos correspondientes junto con sus rectas de regresión. A partir de esto, se hará una comparativa con la teórica para posteriormente sacar conclusiones acerca de la eficiencia de ambas implementaciones y determinar cuál la más eficiente.</p>
<h4><a class="anchor" id="autotoc_md10"></a>
Análsis de la eficiencia teórica del método ShuffleRows</h4>
<p>En primer lugar, llevaremos a cabo un análisis teórico de la eficiencia de la primer versión del método SuffleRows:</p>
<p>void <a class="el" href="classImage.html#a27d5bab7af11a729048b82af06f2d0c0" title="Baraja las filas de una imagen Trabajamos con la representación interna. Contruimos un nuevo puntero ...">Image::ShuffleRows()</a> { </p><pre class="fragment"> const int p = 9973;

 Image temp(rows,cols);

 int newr;

 for (int r=0; r&lt;rows; r++){


     newr = r*p%rows;

     for (int c=0; c&lt;cols;c++)

         temp.set_pixel(newr,c,get_pixel(r,c));

 }

 Copy(temp);
</pre><p>}</p>
<p>En primer lugar, tenemos una sentencia de asignación, operación elemental que es de orden O(1). A continuación, encontramos un doble ciclo for, y analizándolo desde el bucle más interno al más externo obtenemos: </p><div class="image">
<img src="1.png" alt=""/>
</div>
<p> Donde usamos que la eficiencia de set_pixel es de 3, que pertenece a <em><b>O(1)</b></em> </p><div class="image">
<img src="2.png" alt=""/>
</div>
<p> Donde usamos que la eficiencia de la sentencia del bucle externo es de 3, es decir, está en <em><b>O(1)</b></em>. La función Copy(temp) es de orden <em><b>O(rows*cols)</b></em> Por tanto, aplicando la regla de la suma obtenemos que la eficiencia de esta versión del método es <em><b>O(rows*cols)</b></em>(cuadrática).</p>
<p>A continuación, analizaremos de forma teórica la eficiencia de la segunda versión del método ShuffleRows (implementada por osotros):</p>
<p>void <a class="el" href="classImage.html#a27d5bab7af11a729048b82af06f2d0c0" title="Baraja las filas de una imagen Trabajamos con la representación interna. Contruimos un nuevo puntero ...">Image::ShuffleRows()</a>{ </p><pre class="fragment">const int p = 9973;

int topRows = this-&gt;get_rows();

byte ** aux = new byte * [topRows];

for (int r=0; r&lt;topRows; r++)

    aux[r] = img[(r*p)%topRows];

for (int r=0; r&lt;topRows; r++)

    img[r] = aux[r];

delete [] aux;

aux = nullptr;
</pre><p>}</p>
<p>En primer lugar observamos que tenemos 3 sentencias de asignación, cuyas eficiencias son O(1). Posteriormente tenemos un bucle for, en cuyo interior encontramos una sentencia de asignación cuya eficiencia es 5 (dos indexaciones, una asignación y dos operaciones aritméticas). La eficiencia de este bucle es: </p><div class="image">
<img src="3.png" alt=""/>
</div>
<p> A continuación del bucle anterior tenemos otro ciclo for con una sentencia de asignación de eficiencia 3, luego la eficiencia del bucle sería: </p><div class="image">
<img src="4.png" alt=""/>
</div>
<p> Por último tenemos dos sentencias que son ambas O(1), luego aplicando la regla de la suma obtenemos que la eficiencia total del método es O(rows), es decir, lineal.</p>
<h4><a class="anchor" id="autotoc_md11"></a>
Análsis de la eficiencia empírica del método ShuffleRows</h4>
<p>Para llevar este análisis a cabo, se ha usa usado el programa <b>crear_eficiendcia.cpp</b> antes mencionado, para las dos implementaciones del método ShuffleRows (la proporcionada por el profesor y la implementada por nosotros), de tal forma que, tras su ejecución se generará un fichero con los datos necesarios para la obtención de las correspondiente nubes de puntos y las ecuaciones de las curvas que ajustan dichas nubes:</p>
<p><a class="anchor" id="autotoc_md12"></a></p><h5>Primera implementación del método ShuffleRows</h5>
<p>En esta <a href="https://docs.google.com/spreadsheets/d/1SYWKk1WPvJLRwuS6PJvXBKT9ls5G7o3wJFqPSaAuwaQ/edit#gid=0"><b>hoja de cálculo</b></a> se tienen los resultados de la ejecución del programa crear_eficiencia.cpp, para la implementación del método proporcionada por el profesor. A partir de esos datos, se ha usado la graficadora de excel para la generación de las nubes de putos <em><b>(size, elapsed)</b></em>, de <em><b>(rows, T rows)</b></em>, y de <em><b>(cols, T cols)</b></em> ,y sus respectivas curvas de regresión: </p><div class="image">
<img src="5.png" alt=""/>
</div>
<p> A simple vista, observamos que las curvas generadas ajustan bastante bien a los puntos, hecho que se corrobora por ejemplo con el coeficiente de correlación, calculado en la primer gráfica (0.93 (recordemos que cuanto más próximo a 1 mejor ajusta la curva a la nube de puntos)). La función que representa la eficiencia del método y que más se ajusta a los tiempos obtenidos según el tamaño del problema especificado es:</p>
<blockquote class="doxtable">
<p><em><b>f(x) = 1146x^2 – 2313x + 119567</b></em> </p>
</blockquote>
<p>lo cual indica que el método es de clase <em><b>O(n^2)</b></em>. El análisis teórico nos decía que el método era <em><b>O(nrows, ncols)</b></em>, es decir, de orden cuadrático, luego, como bien podemos observar, el resultado obtenido en el análisis teórico se ajusta al obtenido empíricamente, luego, podemos concluir que la eficiencia del método ShuffleRows con la implementación del profesorado es de orden cuadrático.</p>
<p><a class="anchor" id="autotoc_md13"></a></p><h5>Segunda implementación del método ShuffleRows</h5>
<p>En esta <a href="https://docs.google.com/spreadsheets/d/1034-M1tBW7LyZGgVYQIj_lcJyICFL09z33jLlHnSsBk/edit#gid=0"><b>hoja de excel</b></a> se tienen los resultados de la ejecución del programa crear_eficiencia.cpp, para la implementación del método llevada a cabo por nosotros. A partir de esos datos, se ha usado la graficadora de excel para la generación de las nubes de putos <em><b>(size, elapsed)</b></em>, de <em><b>(rows, T rows)</b></em>, y de <em><b>(cols, T cols)</b></em> ,y sus respectivas curvas de regresión: </p><div class="image">
<img src="8.png" alt=""/>
</div>
<p> A simple vista, observamos que las curvas generadas ajustan bastante bien a los puntos, afirmación que se refuerza con con el coeficiente de correlación, calculado en la primer gráfica (0.837 (recordemos que cuanto más próximo a 1 mejor ajusta la curva a la nube de puntos)). La función que representa la eficiencia del método y que más se ajusta a los tiempos obtenidos según el tamaño del problema especificado es:</p>
<blockquote class="doxtable">
<p><em><b>g(x) = 7,47*x + 135</b></em>. </p>
</blockquote>
<p>El análisis teórico nos decía que el método era <em><b>O(nrows)</b></em>, es decir, de orden lineal, luego, como bien podemos observar, en el análisis teórico, la eficiencia era de orden O(n), hecho que se ajusta a la obtenida empíricamente, luego, podemos concluir que la eficiencia del método ShuffleRows con nuestra implementación es de clase O(n); lineal.</p>
<p>Por tanto, tras el análisis concluimos que el cambio de la representación interna de la clase contribuye a la mejora de la eficiencia del método shuffleRows, la cual pasa de ser cuadrática a ser <b>lineal</b>. De este modo, podemos destacar la importancia del uso de la abstracción en la implementación de los métodos de la clase, el cual ha posibilitado que puedan realizarse este tipo de cambios en el código sin grandes cambios en el resto de métodos de la clase.</p>
<blockquote class="doxtable">
<blockquote class="doxtable">
<p>Práctica realizada por: <em><b>Mario Megías Mateo y Quintín Mesa Romero</b></em> </p>
</blockquote>
</blockquote>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
